{
  "estimated_tokens": 0,
  "project_tree": "",
  "files": {
    "internal/builder/builder.go": "package builder\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"goctx/internal/model\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n)\n\nconst AI_PROMPT_HEADER = `You are an AI developer agent. Return ONLY JSON:\\n{\\n  \"short_description\": \"summary\",\\n  \"files\": { \"path\": \"content\" }\\n}`\n\nfunc LoadIgnorePatterns(root string) []string {\n\tpatterns := []string{\".git\", \".stashes\", \"node_modules\", \"goctx\", \"go.sum\", \"ctx.json\"}\n\tf, err := os.Open(filepath.Join(root, \".ctxignore\"))\n\tif err == nil {\n\t\tdefer f.Close()\n\t\tscanner := bufio.NewScanner(f)\n\t\tfor scanner.Scan() {\n\t\t\tline := strings.TrimSpace(scanner.Text())\n\t\t\tif line != \"\" \u0026\u0026 !strings.HasPrefix(line, \"#\") {\n\t\t\t\tpatterns = append(patterns, line)\n\t\t\t}\n\t\t}\n\t}\n\treturn patterns\n}\n\nfunc isBinary(data []byte) bool {\n\treturn bytes.Contains(data, []byte{0})\n}\n\nfunc BuildSelectiveContext(root string, description string) (model.ProjectOutput, error) {\n\tout := model.ProjectOutput{\n\t\tInstructionHeader: AI_PROMPT_HEADER,\n\t\tShortDescription:  description,\n\t\tFiles:             make(map[string]string),\n\t}\n\n\tignorePatterns := LoadIgnorePatterns(root)\n\tdirChan := make(chan string, 10000) // Large buffer for directory paths\n\tvar wg sync.WaitGroup\n\tvar mu sync.Mutex\n\tvar allPaths []string\n\ttotalChars := 0\n\n\t// Worker Pool\n\tfor i := 0; i \u003c 8; i++ {\n\t\tgo func() {\n\t\t\tfor dir := range dirChan {\n\t\t\t\tentries, err := os.ReadDir(dir)\n\t\t\t\tif err != nil {\n\t\t\t\t\twg.Done()\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor _, entry := range entries {\n\t\t\t\t\tfullPath := filepath.Join(dir, entry.Name())\n\t\t\t\t\trelPath, _ := filepath.Rel(root, fullPath)\n\n\t\t\t\t\tignored := false\n\t\t\t\t\tfor _, p := range ignorePatterns {\n\t\t\t\t\t\tif strings.Contains(relPath, p) {\n\t\t\t\t\t\t\tignored = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ignored { continue }\n\n\t\t\t\t\tmu.Lock()\n\t\t\t\t\tallPaths = append(allPaths, relPath)\n\t\t\t\t\tmu.Unlock()\n\n\t\t\t\t\tif entry.IsDir() {\n\t\t\t\t\t\twg.Add(1)\n\t\t\t\t\t\t// Non-blocking push to avoid deadlock\n\t\t\t\t\t\tgo func(p string) { dirChan \u003c- p }(fullPath)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontent, err := os.ReadFile(fullPath)\n\t\t\t\t\t\tif err == nil \u0026\u0026 !isBinary(content) {\n\t\t\t\t\t\t\tmu.Lock()\n\t\t\t\t\t\t\tout.Files[relPath] = string(content)\n\t\t\t\t\t\t\ttotalChars += len(content)\n\t\t\t\t\t\t\tmu.Unlock()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twg.Done()\n\t\t\t}\n\t\t}()\n\t}\n\n\twg.Add(1)\n\tdirChan \u003c- root\n\n\t// This goroutine safely closes the channel once all workers finish\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(dirChan)\n\t}()\n\n\t// Block until the channel is closed and drained\n\tfor range dirChan {}\n\n\tsort.Strings(allPaths)\n\tvar tree strings.Builder\n\tfor _, p := range allPaths {\n\t\tdepth := strings.Count(p, string(os.PathSeparator))\n\t\tindent := \"\"\n\t\tif depth \u003e 0 { indent = strings.Repeat(\"  \", depth) + \"└── \" }\n\t\ttree.WriteString(fmt.Sprintf(\"%s%s\\n\", indent, filepath.Base(p)))\n\t}\n\n\tout.ProjectTree = tree.String()\n\tout.EstimatedTokens = (totalChars + len(out.ProjectTree)) / 4\n\treturn out, nil\n}",
    "internal/model/types.go": "package model\n\ntype Config struct {\n\tIgnore     []string `json:\"ignore\"` \n\tExtensions []string `json:\"extensions\"` \n}\n\ntype ProjectOutput struct {\n\tInstructionHeader string            `json:\"instruction_header,omitempty\"` \n\tShortDescription  string            `json:\"short_description,omitempty\"` \n\tEstimatedTokens   int               `json:\"estimated_tokens\"` \n\tProjectTree       string            `json:\"project_tree\"` \n\tFiles             map[string]string `json:\"files\"` \n}",
    "internal/ui/ui.go": "package ui\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"goctx/internal/apply\"\n\t\"goctx/internal/builder\"\n\t\"goctx/internal/model\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gotk3/gotk3/gdk\"\n\t\"github.com/gotk3/gotk3/glib\"\n\t\"github.com/gotk3/gotk3/gtk\"\n\t\"github.com/sergi/go-diff/diffmatchpatch\"\n)\n\nconst AI_PROMPT_WRAPPER = `SYSTEM: You are a GoCtx AI agent. You have access to the project state below.\\nTo apply changes, output a SINGLE JSON code block. The local orchestrator will scan the clipboard, detect the JSON, and prompt the user to integrate it.\\n\\nFORMAT:\\n\\u0060\\u0060\\u0060json\\n{\\n  \"short_description\": \"Refactor types\",\\n  \"files\": { \"path/file.go\": \"full content...\" }\\n}\\n\\u0060\\u0060\\u0060\\n\\nPROJECT DATA:\\n` \n\nvar (\n\tactiveContext  model.ProjectOutput\n\tlastClipboard  string\n\tstatsBuf       *gtk.TextBuffer\n\tstashList      *gtk.ListBox\n\tpendingList    *gtk.ListBox\n\tpendingPatches []model.ProjectOutput\n\tselectedStash  model.ProjectOutput\n\twin            *gtk.Window\n\tstatusLabel    *gtk.Label\n\tbtnApplyPatch  *gtk.Button\n\tbtnApplyStash  *gtk.Button\n)\n\nfunc Run() {\n\tgtk.Init(nil)\n\twin, _ = gtk.WindowNew(gtk.WINDOW_TOPLEVEL)\n\twin.SetTitle(\"GoCtx Manager\")\n\twin.SetDefaultSize(1400, 950)\n\twin.Connect(\"destroy\", gtk.MainQuit)\n\n\tvmain, _ := gtk.BoxNew(gtk.ORIENTATION_VERTICAL, 0)\n\thmain, _ := gtk.BoxNew(gtk.ORIENTATION_HORIZONTAL, 0)\n\n\tleftBar, _ := gtk.BoxNew(gtk.ORIENTATION_VERTICAL, 15)\n\tleftBar.SetMarginStart(15); leftBar.SetMarginEnd(15); leftBar.SetMarginTop(15)\n\tleftBar.SetSizeRequest(320, -1)\n\n\tbtnBuild := newBtn(\"CURRENT CONTEXT\")\n\tbtnCopy := newBtn(\"COPY CONTEXT\")\n\tbtnApplyPatch = newBtn(\"APPLY SELECTED PATCH\")\n\tbtnApplyStash = newBtn(\"APPLY SELECTED STASH\")\n\tbtnApplyPatch.SetSensitive(false)\n\tbtnApplyStash.SetSensitive(false)\n\n\tleftBar.PackStart(btnBuild, false, false, 0)\n\tleftBar.PackStart(btnCopy, false, false, 0)\n\tleftBar.PackStart(btnApplyPatch, false, false, 0)\n\tleftBar.PackStart(btnApplyStash, false, false, 0)\n\n\t// Pending List with Deselect\n\tlabel(leftBar, \"PENDING PATCHES\")\n\tpendingList, _ = gtk.ListBoxNew()\n\tebPending, _ := gtk.EventBoxNew()\n\tswPending, _ := gtk.ScrolledWindowNew(nil, nil)\n\tswPending.SetSizeRequest(-1, 200)\n\tswPending.Add(pendingList)\n\tebPending.Add(swPending)\n\tebPending.Connect(\"button-press-event\", func() { \n\t\tclearAllSelections()\n\t})\n\tleftBar.PackStart(ebPending, false, false, 0)\n\n\t// Stash List with Deselect\n\tlabel(leftBar, \"STASHES\")\n\tstashList, _ = gtk.ListBoxNew()\n\tebStash, _ := gtk.EventBoxNew()\n\tswStash, _ := gtk.ScrolledWindowNew(nil, nil)\n\tswStash.Add(stashList)\n\tebStash.Add(swStash)\n\tebStash.Connect(\"button-press-event\", func() { \n\t\tclearAllSelections()\n\t})\n\tleftBar.PackStart(ebStash, true, true, 0)\n\n\trightStack, _ := gtk.BoxNew(gtk.ORIENTATION_VERTICAL, 10)\n\trightStack.SetMarginStart(20); rightStack.SetMarginEnd(20); rightStack.SetMarginTop(15)\n\n\tlabel(rightStack, \"CONTEXT TOOL GUI (GOCTX)\")\n\tstatsScroll, _ := gtk.ScrolledWindowNew(nil, nil)\n\tstatsView, _ := gtk.TextViewNew()\n\tstatsView.SetMonospace(true); statsView.SetEditable(false)\n\tstatsView.SetLeftMargin(25); statsView.SetTopMargin(25)\n\tstatsBuf, _ = statsView.GetBuffer()\n\tstatsScroll.Add(statsView)\n\trightStack.PackStart(statsScroll, true, true, 0)\n\n\tsetupTags(statsBuf)\n\n\tstatusPanel, _ := gtk.BoxNew(gtk.ORIENTATION_HORIZONTAL, 0)\n\tstatusLabel, _ = gtk.LabelNew(\"Ready\")\n\tstatusPanel.PackStart(statusLabel, false, false, 10)\n\n\thmain.PackStart(leftBar, false, false, 0)\n\thmain.PackStart(rightStack, true, true, 0)\n\tvmain.PackStart(hmain, true, true, 0)\n\tvmain.PackStart(statusPanel, false, false, 5)\n\n\tbtnBuild.Connect(\"clicked\", func() {\n\t\tgo func() {\n\t\t\tout, err := builder.BuildSelectiveContext(\".\", nil)\n\t\t\tif err == nil {\n\t\t\t\tactiveContext = out\n\t\t\t\tglib.IdleAdd(func() {\n\t\t\t\t\trenderDiff(activeContext, \"Current Workspace State\")\n\t\t\t\t\tupdateStatus(\"Context built\")\n\t\t\t\t})\n\t\t\t}\n\t\t}()\n\t})\n\n\tbtnCopy.Connect(\"clicked\", func() {\n\t\tfullPrompt := AI_PROMPT_WRAPPER + string(mustMarshal(activeContext))\n\t\tclip, _ := gtk.ClipboardGet(gdk.SELECTION_CLIPBOARD)\n\t\tclip.SetText(fullPrompt)\n\t\tupdateStatus(\"System Prompt + Context copied\")\n\t})\n\n\tpendingList.Connect(\"row-selected\", func(_ *gtk.ListBox, row *gtk.ListBoxRow) {\n\t\tif row == nil { return }\n\t\tstashList.UnselectAll()\n\t\tidx := row.GetIndex()\n\t\trenderDiff(pendingPatches[idx], \"Pending Patch Preview\")\n\t\tbtnApplyPatch.SetSensitive(true)\n\t\tbtnApplyStash.SetSensitive(false)\n\t})\n\n\tstashList.Connect(\"row-selected\", func(_ *gtk.ListBox, row *gtk.ListBoxRow) {\n\t\tif row == nil { return }\n\t\tpendingList.UnselectAll()\n\t\tlblWidget, _ := row.GetChild()\n\t\tlbl, _ := lblWidget.(*gtk.Label)\n\t\ttxt, _ := lbl.GetText()\n\t\tdata, err := os.ReadFile(filepath.Join(\".stashes\", txt, \"patch.json\"))\n\t\tif err == nil \u0026\u0026 json.Unmarshal(data, \u0026selectedStash) == nil {\n\t\t\trenderDiff(selectedStash, \"Stash: \"+txt)\n\t\t\tbtnApplyStash.SetSensitive(true)\n\t\t\tbtnApplyPatch.SetSensitive(false)\n\t\t}\n\t})\n\n\tbtnApplyStash.Connect(\"clicked\", func() {\n\t\tif confirmAction(\"Apply selected stash?\") {\n\t\t\tapply.ApplyPatch(\".\", selectedStash)\n\t\t\tupdateStatus(\"Stash applied\")\n\t\t\trefreshStashes(stashList)\n\t\t}\n\t})\n\n\tbtnApplyPatch.Connect(\"clicked\", func() {\n\t\tif confirmAction(\"Apply selected patch?\") {\n\t\t\trow := pendingList.GetSelectedRow()\n\t\t\tif row != nil {\n\t\t\t\tapply.ApplyPatch(\".\", pendingPatches[row.GetIndex()])\n\t\t\t\tupdateStatus(\"Patch applied\")\n\t\t\t\trefreshStashes(stashList)\n\t\t\t}\n\t\t}\n\t})\n\n\tgo func() {\n\t\tfor {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tglib.IdleAdd(func() {\n\t\t\t\tclip, _ := gtk.ClipboardGet(gdk.SELECTION_CLIPBOARD)\n\t\t\t\ttext, _ := clip.WaitForText()\n\t\t\t\tif text != \"\" \u0026\u0026 text != lastClipboard {\n\t\t\t\t\tlastClipboard = text\n\t\t\t\t\tprocessClipboard(text)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}()\n\n\trefreshStashes(stashList)\n\twin.Add(vmain)\n\twin.ShowAll()\n\tgtk.Main()\n}\n\nfunc clearAllSelections() {\n\tpendingList.UnselectAll()\n\tstashList.UnselectAll()\n\tresetView()\n}\n\nfunc resetView() {\n\tbtnApplyPatch.SetSensitive(false)\n\tbtnApplyStash.SetSensitive(false)\n\tstatsBuf.SetText(\"\")\n\tupdateStatus(\"Selection cleared\")\n}\n\nfunc refreshStashes(list *gtk.ListBox) {\n\tglib.IdleAdd(func() bool {\n\t\tlist.GetChildren().Foreach(func(item interface{}) { list.Remove(item.(gtk.IWidget)) })\n\t\tos.MkdirAll(\".stashes\", 0755)\n\t\tfilepath.Walk(\".stashes\", func(path string, info os.FileInfo, err error) error {\n\t\t\tif err == nil \u0026\u0026 info.IsDir() \u0026\u0026 path != \".stashes\" \u0026\u0026 filepath.Dir(path) == \".stashes\" {\n\t\t\t\trow, _ := gtk.ListBoxRowNew()\n\t\t\t\tlbl, _ := gtk.LabelNew(filepath.Base(path))\n\t\t\t\trow.Add(lbl)\n\t\t\t\tlist.Add(row)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tlist.ShowAll()\n\t\treturn false\n\t})\n}\n\nfunc setupTags(buffer *gtk.TextBuffer) {\n\ttab, _ := buffer.GetTagTable()\n\ttagA, _ := gtk.TextTagNew(\"added\"); tagA.SetProperty(\"background\", \"#1e3a1e\"); tagA.SetProperty(\"foreground\", \"#afffbc\"); tab.Add(tagA)\n\ttagD, _ := gtk.TextTagNew(\"deleted\"); tagD.SetProperty(\"background\", \"#4b1818\"); tagD.SetProperty(\"foreground\", \"#ffa1a1\"); tab.Add(tagD)\n\ttagH, _ := gtk.TextTagNew(\"header\"); tagH.SetProperty(\"weight\", 700); tagH.SetProperty(\"foreground\", \"#569cd6\"); tab.Add(tagH)\n}\n\nfunc renderDiff(p model.ProjectOutput, title string) {\n\tstatsBuf.SetText(\"\")\n\tstatsBuf.Insert(statsBuf.GetEndIter(), fmt.Sprintf(\"=== %s ===\\n\\n\", strings.ToUpper(title)))\n\tdmp := diffmatchpatch.New()\n\tfor path, newContent := range p.Files {\n\t\tstatsBuf.InsertWithTag(statsBuf.GetEndIter(), fmt.Sprintf(\"FILE: %s\\n\", path), getTag(\"header\"))\n\t\told, _ := os.ReadFile(path)\n\t\tdiffs := dmp.DiffMain(string(old), newContent, false)\n\t\tfor _, d := range diffs {\n\t\t\tswitch d.Type {\n\t\t\tcase diffmatchpatch.DiffInsert: statsBuf.InsertWithTag(statsBuf.GetEndIter(), d.Text, getTag(\"added\"))\n\t\t\tcase diffmatchpatch.DiffDelete: statsBuf.InsertWithTag(statsBuf.GetEndIter(), d.Text, getTag(\"deleted\"))\n\t\t\tdefault: statsBuf.Insert(statsBuf.GetEndIter(), d.Text)\n\t\t\t}\n\t\t}\n\t\tstatsBuf.Insert(statsBuf.GetEndIter(), \"\\n\")\n\t}\n}\n\nfunc processClipboard(text string) {\n\tre := regexp.MustCompile(`(?s)\\{.*\\\"files\\\".*\\}`)\n\tmatch := re.FindString(text)\n\tif match != \"\" {\n\t\tvar patch model.ProjectOutput\n\t\tif err := json.Unmarshal([]byte(match), \u0026patch); err == nil {\n\t\t\tpendingPatches = append(pendingPatches, patch)\n\t\t\trow, _ := gtk.ListBoxRowNew()\n\t\t\tlbl, _ := gtk.LabelNew(fmt.Sprintf(\"Patch %d (%d files)\", len(pendingPatches), len(patch.Files)))\n\t\t\trow.Add(lbl)\n\t\t\tpendingList.Add(row)\n\t\t\tpendingList.ShowAll()\n\t\t\tupdateStatus(\"New patch detected\")\n\t\t}\n\t}\n}\n\nfunc getTag(n string) *gtk.TextTag { tab, _ := statsBuf.GetTagTable(); t, _ := tab.Lookup(n); return t }\nfunc confirmAction(m string) bool { d := gtk.MessageDialogNew(win, gtk.DIALOG_MODAL, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO, m); r := d.Run(); d.Destroy(); return r == gtk.RESPONSE_YES }\nfunc updateStatus(m string) { statusLabel.SetText(fmt.Sprintf(\"[%s] %s\", time.Now().Format(\"15:04:05\"), m)) }\nfunc mustMarshal(v interface{}) []byte { b, _ := json.MarshalIndent(v, \"\", \"  \"); return b }\nfunc newBtn(l string) *gtk.Button { b, _ := gtk.ButtonNewWithLabel(l); return b }\nfunc label(box *gtk.Box, t string) { l, _ := gtk.LabelNew(t); l.SetXAlign(0); box.PackStart(l, false, false, 0) }\n"
  }
}