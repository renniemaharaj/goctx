{
  "estimated_tokens": 9500,
  "project_tree": ".\ninternal\n  ‚îî‚îÄ‚îÄ builder\n    ‚îî‚îÄ‚îÄ builder.go\n  ‚îî‚îÄ‚îÄ ui\n    ‚îî‚îÄ‚îÄ ui.go\n",
  "files": {
    "internal/builder/builder.go": "package builder\n\nimport (\n\t\"goctx/internal/model\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// BuildSelectiveContext only includes files that match a certain criteria or recent changes\nfunc BuildSelectiveContext(root string, targetFiles []string) (model.ProjectOutput, error) {\n\toutput := model.ProjectOutput{\n\t\tFiles: make(map[string]string),\n\t}\n\n\tfilepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil || info.IsDir() || strings.HasPrefix(path, \".\") {\n\t\t\treturn nil\n\t\t}\n\n\t\trel, _ := filepath.Rel(root, path)\n\t\t\n\t\t// If targetFiles is empty, we act like a full build, \n\t\t// otherwise we only include what is requested.\n\t\tinclude := len(targetFiles) == 0\n\t\tfor _, t := range targetFiles {\n\t\t\tif strings.Contains(rel, t) {\n\t\t\t\tinclude = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif include {\n\t\t\tcontent, _ := os.ReadFile(path)\n\t\t\toutput.Files[rel] = string(content)\n\t\t}\n\t\treturn nil\n\t})\n\n\treturn output, nil\n}",
    "internal/ui/ui.go": "package ui\n\nimport (\n\t\"encoding/json\"\n\t\"goctx/internal/apply\"\n\t\"goctx/internal/builder\"\n\t\"goctx/internal/browser\"\n\t\"goctx/internal/model\"\n\t\"github.com/gotk3/gotk3/gtk\"\n\t\"github.com/gotk3/gotk3/glib\"\n\t\"strings\"\n)\n\nfunc Run() {\n\tgtk.Init(nil)\n\tapplyCSS()\n\n\twin, _ := gtk.WindowNew(gtk.WINDOW_TOPLEVEL)\n\twin.SetTitle(\"‚óè GoCtx Patch Mode\")\n\twin.SetDefaultSize(1200, 850)\n\n\tbody, _ := gtk.BoxNew(gtk.ORIENTATION_VERTICAL, 10)\n\tbody.SetMarginStart(20)\n\tbody.SetMarginEnd(20)\n\n\t// View of what is being sent\n\tsw, _ := gtk.ScrolledWindowNew(nil, nil)\n\ttv, _ := gtk.TextViewNew()\n\ttv.SetMonospace(true)\n\tbuf, _ := tv.GetBuffer()\n\tsw.Add(tv)\n\tbody.PackStart(sw, true, true, 0)\n\n\tlabel(body, \"AI INSTRUCTIONS (Target specific files with @filename)\")\n\tpromptView, _ := gtk.TextViewNew()\n\tpBuf, _ := promptView.GetBuffer()\n\tbody.PackStart(promptView, false, false, 0)\n\n\tbtnAI := newBtn(\"üöÄ APPLY SMART PATCH\")\n\tbody.PackStart(btnAI, false, false, 20)\n\n\tbtnAI.Connect(\"clicked\", func() {\n\t\tstart, end := pBuf.GetBounds()\n\t\tinstruction, _ := pBuf.GetText(start, end, false)\n\t\t\n\t\t// Extract file mentions from prompt (e.g., \"change @ui.go\")\n\t\ttargets := []string{}\n\t\twords := strings.Split(instruction, \" \")\n\t\tfor _, w := range words {\n\t\t\tif strings.HasPrefix(w, \"@\") {\n\t\t\t\ttargets = append(targets, strings.TrimPrefix(w, \"@\"))\n\t\t\t}\n\t\t}\n\n\t\t// Build a selective context to save tokens/bandwidth\n\t\tcurrCtx, _ := builder.BuildSelectiveContext(\".\", targets)\n\t\tctxJS, _ := json.Marshal(currCtx)\n\t\t\n\t\tfullPrompt := \"TASK: \" + instruction + \"\\n\\nONLY return a JSON patch for these files:\\n\" + string(ctxJS)\n\t\tbuf.SetText(\"// Sending partial state for: \" + strings.Join(targets, \", \"))\n\t\t\n\t\tgo func() {\n\t\t\tupdatedState, err := browser.ProcessWithAI(fullPrompt)\n\t\t\tglib.IdleAdd(func() {\n\t\t\t\tif err != nil {\n\t\t\t\t\tbuf.SetText(\"// ERROR: \" + err.Error())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// apply.ApplyPatch handles partial file maps naturally\n\t\t\t\tapply.ApplyPatch(\".\", updatedState)\n\t\t\t\tbuf.SetText(\"// PATCH APPLIED SUCCESS\")\n\t\t\t})\n\t\t}()\n\t})\n\n\twin.Add(body)\n\twin.ShowAll()\n\tgtk.Main()\n}\n"
  }
}