{
  "estimated_tokens": 0,
  "project_tree": "",
  "files": {
    "internal/builder/builder.go": "package builder\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"goctx/internal/model\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n)\n\nconst AI_PROMPT_HEADER = `You are an AI developer agent. Return ONLY JSON:\\n{\\n  \"short_description\": \"summary\",\\n  \"files\": { \"path\": \"content\" }\\n}`\n\nfunc LoadIgnorePatterns(root string) []string {\n\tpatterns := []string{\".git\", \".stashes\", \"node_modules\", \"goctx\", \"go.sum\", \"ctx.json\", \".exe\", \".bin\"}\n\tf, err := os.Open(filepath.Join(root, \".ctxignore\"))\n\tif err == nil {\n\t\tdefer f.Close()\n\t\tscanner := bufio.NewScanner(f)\n\t\tfor scanner.Scan() {\n\t\t\tline := strings.TrimSpace(scanner.Text())\n\t\t\tif line != \"\" \u0026\u0026 !strings.HasPrefix(line, \"#\") {\n\t\t\t\tpatterns = append(patterns, line)\n\t\t\t}\n\t\t}\n\t}\n\treturn patterns\n}\n\nfunc isBinary(data []byte) bool {\n\treturn bytes.Contains(data, []byte{0})\n}\n\nfunc BuildSelectiveContext(root string, description string) (model.ProjectOutput, error) {\n\tabsRoot, _ := filepath.Abs(root)\n\tout := model.ProjectOutput{\n\t\tInstructionHeader: AI_PROMPT_HEADER,\n\t\tShortDescription:  description,\n\t\tFiles:             make(map[string]string),\n\t}\n\n\tignorePatterns := LoadIgnorePatterns(absRoot)\n\tdirChan := make(chan string, 10000)\n\tvar wg sync.WaitGroup\n\tvar mu sync.Mutex\n\tvar allPaths []string\n\ttotalChars := 0\n\n\t// Worker Pool\n\tfor i := 0; i \u003c 8; i++ {\n\t\tgo func() {\n\t\t\tfor dir := range dirChan {\n\t\t\t\tentries, err := os.ReadDir(dir)\n\t\t\t\tif err != nil {\n\t\t\t\t\twg.Done()\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor _, entry := range entries {\n\t\t\t\t\tfullPath := filepath.Join(dir, entry.Name())\n\t\t\t\t\trelPath, _ := filepath.Rel(absRoot, fullPath)\n\n\t\t\t\t\tignored := false\n\t\t\t\t\tfor _, p := range ignorePatterns {\n\t\t\t\t\t\tif strings.Contains(relPath, p) {\n\t\t\t\t\t\t\tignored = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ignored { continue }\n\n\t\t\t\t\tmu.Lock()\n\t\t\t\t\tallPaths = append(allPaths, relPath)\n\t\t\t\t\tmu.Unlock()\n\n\t\t\t\t\tif entry.IsDir() {\n\t\t\t\t\t\twg.Add(1)\n\t\t\t\t\t\tdirChan \u003c- fullPath\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontent, err := os.ReadFile(fullPath)\n\t\t\t\t\t\tif err == nil \u0026\u0026 !isBinary(content) {\n\t\t\t\t\t\t\tmu.Lock()\n\t\t\t\t\t\t\tout.Files[relPath] = string(content)\n\t\t\t\t\t\t\ttotalChars += len(content)\n\t\t\t\t\t\t\tmu.Unlock()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twg.Done()\n\t\t\t}\n\t\t}()\n\t}\n\n\twg.Add(1)\n\tdirChan \u003c- absRoot\n\n\t// Wait for all discoveries to finish\n\twg.Wait()\n\tclose(dirChan)\n\n\tsort.Strings(allPaths)\n\tvar tree strings.Builder\n\tfor _, p := range allPaths {\n\t\tdepth := strings.Count(p, string(os.PathSeparator))\n\t\tindent := \"\"\n\t\tif depth \u003e 0 { \n\t\t\tindent = strings.Repeat(\"  \", depth-1) + \"└── \" \n\t\t} else if p != \".\" {\n\t\t\tindent = \"\"\n\t\t}\n\t\ttree.WriteString(fmt.Sprintf(\"%s%s\\n\", indent, filepath.Base(p)))\n\t}\n\n\tout.ProjectTree = tree.String()\n\tout.EstimatedTokens = (totalChars + len(out.ProjectTree)) / 4\n\treturn out, nil\n}"
  }
}