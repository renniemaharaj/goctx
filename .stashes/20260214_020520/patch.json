{
  "estimated_tokens": 0,
  "project_tree": "",
  "files": {
    "internal/builder/builder.go": "package builder\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"goctx/internal/model\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n)\n\nconst AI_PROMPT_HEADER = `You are an AI developer agent. Return ONLY JSON:\\n{\\n  \"short_description\": \"summary\",\\n  \"files\": { \"path\": \"content\" }\\n}`\n\nfunc LoadIgnorePatterns(root string) []string {\n\tpatterns := []string{\".git\", \".stashes\", \"node_modules\", \"goctx\", \"go.sum\", \"ctx.json\"}\n\tf, err := os.Open(filepath.Join(root, \".ctxignore\"))\n\tif err == nil {\n\t\tdefer f.Close()\n\t\tscanner := bufio.NewScanner(f)\n\t\tfor scanner.Scan() {\n\t\t\tline := strings.TrimSpace(scanner.Text())\n\t\t\tif line != \"\" \u0026\u0026 !strings.HasPrefix(line, \"#\") {\n\t\t\t\tpatterns = append(patterns, line)\n\t\t\t}\n\t\t}\n\t}\n\treturn patterns\n}\n\nfunc isBinary(data []byte) bool {\n\treturn bytes.Contains(data, []byte{0})\n}\n\nfunc BuildSelectiveContext(root string, description string) (model.ProjectOutput, error) {\n\tout := model.ProjectOutput{\n\t\tInstructionHeader: AI_PROMPT_HEADER,\n\t\tShortDescription:  description,\n\t\tFiles:             make(map[string]string),\n\t}\n\n\tignorePatterns := LoadIgnorePatterns(root)\n\tdirChan := make(chan string, 10000) // Large buffer for directory paths\n\tvar wg sync.WaitGroup\n\tvar mu sync.Mutex\n\tvar allPaths []string\n\ttotalChars := 0\n\n\t// Worker Pool\n\tfor i := 0; i \u003c 8; i++ {\n\t\tgo func() {\n\t\t\tfor dir := range dirChan {\n\t\t\t\tentries, err := os.ReadDir(dir)\n\t\t\t\tif err != nil {\n\t\t\t\t\twg.Done()\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor _, entry := range entries {\n\t\t\t\t\tfullPath := filepath.Join(dir, entry.Name())\n\t\t\t\t\trelPath, _ := filepath.Rel(root, fullPath)\n\n\t\t\t\t\tignored := false\n\t\t\t\t\tfor _, p := range ignorePatterns {\n\t\t\t\t\t\tif strings.Contains(relPath, p) {\n\t\t\t\t\t\t\tignored = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ignored { continue }\n\n\t\t\t\t\tmu.Lock()\n\t\t\t\t\tallPaths = append(allPaths, relPath)\n\t\t\t\t\tmu.Unlock()\n\n\t\t\t\t\tif entry.IsDir() {\n\t\t\t\t\t\twg.Add(1)\n\t\t\t\t\t\t// Non-blocking push to avoid deadlock\n\t\t\t\t\t\tgo func(p string) { dirChan \u003c- p }(fullPath)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontent, err := os.ReadFile(fullPath)\n\t\t\t\t\t\tif err == nil \u0026\u0026 !isBinary(content) {\n\t\t\t\t\t\t\tmu.Lock()\n\t\t\t\t\t\t\tout.Files[relPath] = string(content)\n\t\t\t\t\t\t\ttotalChars += len(content)\n\t\t\t\t\t\t\tmu.Unlock()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twg.Done()\n\t\t\t}\n\t\t}()\n\t}\n\n\twg.Add(1)\n\tdirChan \u003c- root\n\n\t// This goroutine safely closes the channel once all workers finish\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(dirChan)\n\t}()\n\n\t// Block until the channel is closed and drained\n\tfor range dirChan {}\n\n\tsort.Strings(allPaths)\n\tvar tree strings.Builder\n\tfor _, p := range allPaths {\n\t\tdepth := strings.Count(p, string(os.PathSeparator))\n\t\tindent := \"\"\n\t\tif depth \u003e 0 { indent = strings.Repeat(\"  \", depth) + \"└── \" }\n\t\ttree.WriteString(fmt.Sprintf(\"%s%s\\n\", indent, filepath.Base(p)))\n\t}\n\n\tout.ProjectTree = tree.String()\n\tout.EstimatedTokens = (totalChars + len(out.ProjectTree)) / 4\n\treturn out, nil\n}",
    "internal/ui/ui.go": "package ui\n\nimport (\n\t\"fmt\"\n\t\"goctx/internal/builder\"\n\t\"goctx/internal/model\"\n\t\"os\"\n\t\"sort\"\n\t\"unicode/utf8\"\n\t\"github.com/gotk3/gotk3/glib\"\n\t\"github.com/gotk3/gotk3/gtk\"\n\t\"github.com/sergi/go-diff/diffmatchpatch\"\n)\n\nvar (\n\tactiveContext  model.ProjectOutput\n\tstatsBuf       *gtk.TextBuffer\n\twin            *gtk.Window\n)\n\nfunc Run() {\n\tgtk.Init(nil)\n\twin, _ = gtk.WindowNew(gtk.WINDOW_TOPLEVEL)\n\twin.SetTitle(\"GoCtx Manager v2.4\")\n\twin.SetDefaultSize(1200, 800)\n\twin.Connect(\"destroy\", gtk.MainQuit)\n\n\tgrid, _ := gtk.GridNew()\n\tgrid.SetColumnSpacing(10)\n\tgrid.SetRowSpacing(10)\n\tgrid.SetBorderWidth(10)\n\n\tsidebar, _ := gtk.BoxNew(gtk.ORIENTATION_VERTICAL, 10)\n\tsidebar.SetSizeRequest(250, -1)\n\n\tbtnBuild := newBtn(\"BUILD CONTEXT\")\n\tsidebar.PackStart(btnBuild, false, false, 0)\n\tgrid.Attach(sidebar, 0, 0, 1, 1)\n\n\tsw, _ := gtk.ScrolledWindowNew(nil, nil)\n\tsw.SetHExpand(true)\n\tsw.SetVExpand(true)\n\tsw.SetPolicy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)\n\n\tstatsView, _ := gtk.TextViewNew()\n\tstatsView.SetMonospace(true)\n\tstatsView.SetEditable(false)\n\t\n\tstatsBuf, _ = statsView.GetBuffer()\n\tsetupTags(statsBuf)\n\tsw.Add(statsView)\n\tgrid.Attach(sw, 1, 0, 1, 1)\n\n\tbtnBuild.Connect(\"clicked\", func() {\n\t\tgo func() {\n\t\t\tout, err := builder.BuildSelectiveContext(\".\", \"Manual Build\")\n\t\t\tif err == nil {\n\t\t\t\tactiveContext = out\n\t\t\t\tglib.IdleAdd(func() {\n\t\t\t\t\trenderDiff(activeContext)\n\t\t\t\t})\n\t\t\t}\n\t\t}()\n\t})\n\n\twin.Add(grid)\n\twin.ShowAll()\n\tgtk.Main()\n}\n\nfunc setupTags(b *gtk.TextBuffer) {\n\ttab, _ := b.GetTagTable()\n\ta, _ := gtk.TextTagNew(\"added\"); a.SetProperty(\"foreground\", \"#2ecc71\"); tab.Add(a)\n\td, _ := gtk.TextTagNew(\"deleted\"); d.SetProperty(\"foreground\", \"#e74c3c\"); tab.Add(d)\n\th, _ := gtk.TextTagNew(\"header\"); h.SetProperty(\"foreground\", \"#3498db\"); h.SetProperty(\"weight\", 700); tab.Add(h)\n\twar, _ := gtk.TextTagNew(\"warn\"); war.SetProperty(\"foreground\", \"#f39c12\"); war.SetProperty(\"style\", gtk.STYLE_ITALIC); tab.Add(war)\n}\n\nfunc renderDiff(p model.ProjectOutput) {\n\tstatsBuf.SetText(\"\")\n\tdmp := diffmatchpatch.New()\n\t\n\tvar keys []string\n\tfor k := range p.Files { keys = append(keys, k) }\n\tsort.Strings(keys)\n\n\trenderCount := 0\n\tconst limit = 10\n\n\tfor _, path := range keys {\n\t\tif renderCount \u003e= limit { break }\n\n\t\tcontent := p.Files[path]\n\t\tif !utf8.ValidString(content) { continue }\n\n\t\tstatsBuf.InsertWithTag(statsBuf.GetEndIter(), \"\\nFILE: \"+path+\"\\n\", getTag(\"header\"))\n\t\told, _ := os.ReadFile(path)\n\t\t// Diff validation: ensure old content is also valid UTF8\n\t\toldStr := string(old)\n\t\tif !utf8.ValidString(oldStr) { oldStr = \"[Binary or Invalid UTF-8 Content]\" }\n\t\t\n\t\tdiffs := dmp.DiffMain(oldStr, content, false)\n\t\t\n\t\tfor _, d := range diffs {\n\t\t\tif utf8.ValidString(d.Text) {\n\t\t\t\tswitch d.Type {\n\t\t\t\tcase diffmatchpatch.DiffInsert: statsBuf.InsertWithTag(statsBuf.GetEndIter(), d.Text, getTag(\"added\"))\n\t\t\t\tcase diffmatchpatch.DiffDelete: statsBuf.InsertWithTag(statsBuf.GetEndIter(), d.Text, getTag(\"deleted\"))\n\t\t\t\tdefault: statsBuf.Insert(statsBuf.GetEndIter(), d.Text)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trenderCount++\n\t}\n\n\tif len(keys) \u003e limit {\n\t\tmsg := fmt.Sprintf(\"\\n\\n--- PREVIEW LIMIT REACHED: %d/%d files rendered. Full context is in ctx.json ---\", limit, len(keys))\n\t\tstatsBuf.InsertWithTag(statsBuf.GetEndIter(), msg, getTag(\"warn\"))\n\t}\n}\n\nfunc getTag(n string) *gtk.TextTag { tab, _ := statsBuf.GetTagTable(); t, _ := tab.Lookup(n); return t }\nfunc newBtn(l string) *gtk.Button { b, _ := gtk.ButtonNewWithLabel(l); return b }\n"
  }
}