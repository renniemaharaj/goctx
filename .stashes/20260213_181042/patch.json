{
  "estimated_tokens": 1695,
  "project_tree": ".\nassets\n  └── style.css\ngo.mod\ngo.sum\ngoctx\ninternal\n  └── apply\n    └── apply.go\n  └── builder\n    └── context.go\n  └── config\n    └── config.go\n  └── model\n    └── types.go\n  └── overlay\n    └── overlay.go\n    └── x11.go\n  └── stash\n    └── stash.go\n  └── ui\n    └── ui.go\nmain.go\nui\n  └── window.go\n",
  "files": {
    "internal/apply/apply.go": "package apply\n\nimport (\n\t\"errors\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"goctx/internal/model\"\n\t\"goctx/internal/stash\"\n)\n\nfunc ApplyPatch(root string, input model.ProjectOutput) error {\n\tif len(input.Files) == 0 {\n\t\treturn errors.New(\"no files to apply\")\n\t}\n\n\tstashID, err := stash.CreateStash(root, input)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor path, content := range input.Files {\n\t\tif !safePath(root, path) {\n\t\t\tcontinue\n\t\t}\n\n\t\tos.MkdirAll(filepath.Dir(path), 0755)\n\t\tos.WriteFile(path, []byte(content), 0644)\n\t}\n\n\treturn stash.MarkApplied(root, stashID)\n}\n\nfunc safePath(root, path string) bool {\n\tabs, _ := filepath.Abs(path)\n\trootAbs, _ := filepath.Abs(root)\n\treturn strings.HasPrefix(abs, rootAbs)\n}\n",
    "internal/builder/context.go": "package builder\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"goctx/internal/model\"\n)\n\nfunc defaultConfig() model.Config {\n\treturn model.Config{\n\t\tIgnore:     []string{\".git\", \".stashes\"},\n\t\tExtensions: []string{\".go\", \".json\", \".md\"},\n\t}\n}\n\nfunc BuildContext(root string) (model.ProjectOutput, error) {\n\tcfg := defaultConfig()\n\n\toutput := model.ProjectOutput{\n\t\tFiles: make(map[string]string),\n\t}\n\n\tvar tree strings.Builder\n\ttotalChars := 0\n\n\terr := filepath.WalkDir(root, func(path string, d os.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, ig := range cfg.Ignore {\n\t\t\tif strings.Contains(path, ig) {\n\t\t\t\tif d.IsDir() {\n\t\t\t\t\treturn filepath.SkipDir\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tdepth := strings.Count(path, string(os.PathSeparator))\n\t\tindent := \"\"\n\t\tif depth \u003e 0 {\n\t\t\tindent = strings.Repeat(\"  \", depth) + \"└── \"\n\t\t}\n\t\ttree.WriteString(fmt.Sprintf(\"%s%s\\n\", indent, d.Name()))\n\n\t\tif !d.IsDir() \u0026\u0026 allowed(path, cfg.Extensions) {\n\t\t\tcontent, err := os.ReadFile(path)\n\t\t\tif err == nil {\n\t\t\t\tstr := string(content)\n\t\t\t\toutput.Files[path] = str\n\t\t\t\ttotalChars += len(str)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn output, err\n\t}\n\n\toutput.ProjectTree = tree.String()\n\toutput.EstimatedTokens = (totalChars + len(output.ProjectTree)) / 4\n\n\treturn output, nil\n}\n\nfunc allowed(path string, exts []string) bool {\n\text := filepath.Ext(path)\n\tfor _, e := range exts {\n\t\tif ext == e {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n",
    "internal/config/config.go": "package config\n\nconst (\n\tOverlayOpacity25 = 0.25\n\tOverlayOpacity50 = 0.50\n\tOverlayOpacity75 = 0.75\n\tOverlayOpacity100 = 1.00\n)\n",
    "internal/model/types.go": "package model\n\ntype Config struct {\n\tIgnore     []string `json:\"ignore\"`\n\tExtensions []string `json:\"extensions\"`\n}\n\ntype ProjectOutput struct {\n\tEstimatedTokens int               `json:\"estimated_tokens\"`\n\tProjectTree     string            `json:\"project_tree\"`\n\tFiles           map[string]string `json:\"files\"`\n}\n",
    "internal/overlay/overlay.go": "package overlay\n\ntype Overlay interface {\n\tStart() error\n\tSetOpacity(float64)\n\tShow()\n\tHide()\n}\n",
    "internal/overlay/x11.go": "package overlay\n\nimport (\n\t\"github.com/gotk3/gotk3/gdk\"\n\t\"github.com/gotk3/gotk3/gtk\"\n)\n\ntype X11Overlay struct {\n\twindow *gtk.Window\n}\n\nfunc NewX11Overlay() *X11Overlay {\n\twin, _ := gtk.WindowNew(gtk.WINDOW_TOPLEVEL)\n\n\twin.SetDecorated(false)\n\twin.SetKeepAbove(true)\n\twin.SetAppPaintable(true)\n\twin.SetAcceptFocus(false)\n\twin.SetSkipTaskbarHint(true)\n\twin.SetSkipPagerHint(true)\n\t// win.SetTypeHint(gtk.WINDOW_TYPE_HINT_DOCK)\n\n\t// Enable transparency\n\tscreen := win.GetScreen()\n\tvisual, _ := screen.GetRGBAVisual()\n\tif visual != nil {\n\t\twin.SetVisual(visual)\n\t}\n\n\t// Make background transparent\n\twin.Connect(\"draw\", func(w *gtk.Window, cr *gdk.CairoContext) {\n\t\tcr.SetSourceRGBA(0, 0, 0, 0.5) // 50% black tint\n\t\tcr.Paint()\n\t})\n\n\twin.Fullscreen()\n\n\treturn \u0026X11Overlay{\n\t\twindow: win,\n\t}\n}\n\nfunc (o *X11Overlay) Start() error {\n\to.window.ShowAll()\n\treturn nil\n}\n\nfunc (o *X11Overlay) SetOpacity(val float64) {\n\to.window.SetOpacity(val)\n}\n\nfunc (o *X11Overlay) Show() {\n\to.window.Show()\n}\n\nfunc (o *X11Overlay) Hide() {\n\to.window.Hide()\n}\n",
    "internal/stash/stash.go": "package stash\n\nimport (\n\t\"encoding/json\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n\n\t\"goctx/internal/model\"\n)\n\nfunc CreateStash(root string, patch model.ProjectOutput) (string, error) {\n\tid := time.Now().Format(\"20060102_150405\")\n\tbase := filepath.Join(root, \".stashes\", id)\n\n\tos.MkdirAll(filepath.Join(base, \"backup\"), 0755)\n\n\tfor path := range patch.Files {\n\t\tif _, err := os.Stat(path); err == nil {\n\t\t\tdata, _ := os.ReadFile(path)\n\t\t\tbpath := filepath.Join(base, \"backup\", path)\n\t\t\tos.MkdirAll(filepath.Dir(bpath), 0755)\n\t\t\tos.WriteFile(bpath, data, 0644)\n\t\t}\n\t}\n\n\tpatchData, _ := json.MarshalIndent(patch, \"\", \"  \")\n\tos.WriteFile(filepath.Join(base, \"patch.json\"), patchData, 0644)\n\n\treturn id, nil\n}\n\nfunc MarkApplied(root, id string) error {\n\tmeta := map[string]string{\n\t\t\"applied\":   \"true\",\n\t\t\"timestamp\": time.Now().String(),\n\t}\n\tdata, _ := json.MarshalIndent(meta, \"\", \"  \")\n\treturn os.WriteFile(filepath.Join(root, \".stashes\", id, \"meta.json\"), data, 0644)\n}\n",
    "internal/ui/ui.go": "package ui\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n\n\t\"github.com/gotk3/gotk3/gtk\"\n)\n\nfunc Run() {\n\tgtk.Init(nil)\n\n\twin, _ := gtk.WindowNew(gtk.WINDOW_TOPLEVEL)\n\twin.SetTitle(\"goctx GUI\")\n\twin.SetDefaultSize(800, 600)\n\twin.Connect(\"destroy\", gtk.MainQuit)\n\n\tbox, _ := gtk.BoxNew(gtk.ORIENTATION_VERTICAL, 5)\n\n\tbtnContext, _ := gtk.ButtonNewWithLabel(\"Capture Context\")\n\tbtnContext.Connect(\"clicked\", func() {\n\t\tcmd := exec.Command(\"goctx\")\n\t\tout, err := cmd.Output()\n\t\tif err == nil {\n\t\t\tfmt.Println(string(out))\n\t\t}\n\t})\n\n\tbox.Add(btnContext)\n\twin.Add(box)\n\n\twin.ShowAll()\n\tgtk.Main()\n}\n",
    "main.go": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"goctx/internal/apply\"\n\t\"goctx/internal/builder\"\n\t\"goctx/internal/model\"\n\t\"goctx/internal/ui\"\n)\n\nfunc main() {\n\tif len(os.Args) == 1 {\n\t\trunBuild()\n\t\treturn\n\t}\n\n\tswitch os.Args[1] {\n\tcase \"apply\":\n\t\trunApply()\n\tcase \"gui\":\n\t\trunGUI()\n\tdefault:\n\t\tfmt.Println(\"Usage:\")\n\t\tfmt.Println(\"  goctx           Build context to stdout\")\n\t\tfmt.Println(\"  goctx apply     Apply JSON patch from stdin\")\n\t\tfmt.Println(\"  goctx gui       Launch GUI\")\n\t}\n}\n\nfunc runBuild() {\n\toutput, err := builder.BuildContext(\".\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tenc := json.NewEncoder(os.Stdout)\n\tenc.SetIndent(\"\", \"  \")\n\tenc.Encode(output)\n}\n\nfunc runApply() {\n\tvar input model.ProjectOutput\n\terr := json.NewDecoder(os.Stdin).Decode(\u0026input)\n\tif err != nil {\n\t\tfmt.Println(\"Invalid JSON input\")\n\t\treturn\n\t}\n\n\terr = apply.ApplyPatch(\".\", input)\n\tif err != nil {\n\t\tfmt.Println(\"Apply failed:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Patch applied successfully.\")\n}\n\nfunc runGUI() {\n\tui.Run()\n}\n",
    "ui/window.go": "package ui\n\n// reserved for future UI components\n"
  }
}