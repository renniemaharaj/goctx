{
  "estimated_tokens": 0,
  "project_tree": "",
  "files": {
    "internal/ui/ui.go": "package ui\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"goctx/internal/apply\"\n\t\"goctx/internal/builder\"\n\t\"goctx/internal/model\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode/utf8\"\n\n\t\"github.com/gotk3/gotk3/gdk\"\n\t\"github.com/gotk3/gotk3/glib\"\n\t\"github.com/gotk3/gotk3/gtk\"\n\t\"github.com/sergi/go-diff/diffmatchpatch\"\n)\n\nconst AI_PROMPT_WRAPPER = `SYSTEM: You are a GoCtx AI agent. You have access to the project state below.\\nTo apply changes, output a SINGLE JSON code block.\\n`\n\nvar (\n\tactiveContext  model.ProjectOutput\n\tlastClipboard  string\n\tstatsBuf       *gtk.TextBuffer\n\tstashList      *gtk.ListBox\n\tpendingList    *gtk.ListBox\n\tpendingPatches []model.ProjectOutput\n\tselectedStash  model.ProjectOutput\n\twin            *gtk.Window\n\tstatusLabel    *gtk.Label\n\tbtnApplyPatch  *gtk.Button\n\tbtnApplyStash  *gtk.Button\n)\n\nfunc Run() {\n\tgtk.Init(nil)\n\twin, _ = gtk.WindowNew(gtk.WINDOW_TOPLEVEL)\n\twin.SetTitle(\"GoCtx Manager\")\n\twin.SetDefaultSize(1400, 950)\n\twin.Connect(\"destroy\", gtk.MainQuit)\n\n\tvmain, _ := gtk.BoxNew(gtk.ORIENTATION_VERTICAL, 0)\n\thmain, _ := gtk.BoxNew(gtk.ORIENTATION_HORIZONTAL, 0)\n\n\tleftBar, _ := gtk.BoxNew(gtk.ORIENTATION_VERTICAL, 15)\n\tleftBar.SetMarginStart(15)\n\tleftBar.SetMarginEnd(15)\n\tleftBar.SetMarginTop(15)\n\tleftBar.SetSizeRequest(320, -1)\n\n\tbtnBuild := newBtn(\"CURRENT CONTEXT\")\n\tbtnCopy := newBtn(\"COPY CONTEXT\")\n\tbtnApplyPatch = newBtn(\"APPLY SELECTED PATCH\")\n\tbtnApplyStash = newBtn(\"APPLY SELECTED STASH\")\n\tbtnApplyPatch.SetSensitive(false)\n\tbtnApplyStash.SetSensitive(false)\n\n\tleftBar.PackStart(btnBuild, false, false, 0)\n\tleftBar.PackStart(btnCopy, false, false, 0)\n\tleftBar.PackStart(btnApplyPatch, false, false, 0)\n\tleftBar.PackStart(btnApplyStash, false, false, 0)\n\n\tlabel(leftBar, \"PENDING PATCHES\")\n\tpendingList, _ = gtk.ListBoxNew()\n\tswPending, _ := gtk.ScrolledWindowNew(nil, nil)\n\tswPending.SetSizeRequest(-1, 200)\n\tswPending.Add(pendingList)\n\tleftBar.PackStart(swPending, false, false, 0)\n\n\tlabel(leftBar, \"STASHES\")\n\tstashList, _ = gtk.ListBoxNew()\n\tswStash, _ := gtk.ScrolledWindowNew(nil, nil)\n\tswStash.Add(stashList)\n\tleftBar.PackStart(swStash, true, true, 0)\n\n\trightStack, _ := gtk.BoxNew(gtk.ORIENTATION_VERTICAL, 10)\n\trightStack.SetMarginStart(20)\n\trightStack.SetMarginEnd(20)\n\trightStack.SetMarginTop(15)\n\n\tstatsScroll, _ := gtk.ScrolledWindowNew(nil, nil)\n\tstatsView, _ := gtk.TextViewNew()\n\tstatsView.SetMonospace(true)\n\tstatsView.SetEditable(false)\n\tstatsBuf, _ = statsView.GetBuffer()\n\tstatsScroll.Add(statsView)\n\trightStack.PackStart(statsScroll, true, true, 0)\n\n\tsetupTags(statsBuf)\n\tstatusLabel, _ = gtk.LabelNew(\"Ready\")\n\n\thmain.PackStart(leftBar, false, false, 0)\n\thmain.PackStart(rightStack, true, true, 0)\n\tvmain.PackStart(hmain, true, true, 0)\n\tvmain.PackStart(statusLabel, false, false, 5)\n\n\tbtnBuild.Connect(\"clicked\", func() {\n\t\tupdateStatus(\"Building context...\")\n\t\tgo func() {\n\t\t\troot, _ := filepath.Abs(\".\")\n\t\t\tout, err := builder.BuildSelectiveContext(root, \"Manual Build\")\n\t\t\tglib.IdleAdd(func() {\n\t\t\t\tif err != nil {\n\t\t\t\t\tupdateStatus(\"Error: \" + err.Error())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tactiveContext = out\n\t\t\t\trenderDiff(activeContext, \"Current Workspace\")\n\t\t\t\tupdateStatus(\"Context built successfully\")\n\t\t\t})\n\t\t}()\n\t})\n\n\tbtnCopy.Connect(\"clicked\", func() {\n\t\tfullPrompt := AI_PROMPT_WRAPPER + string(mustMarshal(activeContext))\n\t\tclip, _ := gtk.ClipboardGet(gdk.SELECTION_CLIPBOARD)\n\t\tclip.SetText(fullPrompt)\n\t\tupdateStatus(\"Prompt copied to clipboard\")\n\t})\n\n\tpendingList.Connect(\"row-selected\", func(_ *gtk.ListBox, row *gtk.ListBoxRow) {\n\t\tif row == nil { return }\n\t\tidx := row.GetIndex()\n\t\trenderDiff(pendingPatches[idx], \"Pending Patch\")\n\t\tbtnApplyPatch.SetSensitive(true)\n\t})\n\n\tgo func() {\n\t\tfor {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tglib.IdleAdd(func() {\n\t\t\t\tclip, _ := gtk.ClipboardGet(gdk.SELECTION_CLIPBOARD)\n\t\t\t\ttext, _ := clip.WaitForText()\n\t\t\t\tif text != \"\" \u0026\u0026 text != lastClipboard {\n\t\t\t\t\tlastClipboard = text\n\t\t\t\t\tprocessClipboard(text)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}()\n\n\trefreshStashes(stashList)\n\twin.Add(vmain)\n\twin.ShowAll()\n\tgtk.Main()\n}\n\nfunc renderDiff(p model.ProjectOutput, title string) {\n\tstatsBuf.SetText(\"\")\n\titer := statsBuf.GetStartIter()\n\t\n\tstatsBuf.InsertWithTag(iter, fmt.Sprintf(\"=== %s ===\\n\\n\", strings.ToUpper(title)), getTag(\"header\"))\n\t\n\tif p.ProjectTree != \"\" {\n\t\tstatsBuf.Insert(statsBuf.GetEndIter(), \"STRUCTURE:\\n\"+p.ProjectTree+\"\\n---\\n\\n\")\n\t}\n\n\tdmp := diffmatchpatch.New()\n\tkeys := make([]string, 0, len(p.Files))\n\tfor k := range p.Files { keys = append(keys, k) }\n\tsort.Strings(keys)\n\n\tfor _, path := range keys {\n\t\tstatsBuf.InsertWithTag(statsBuf.GetEndIter(), \"FILE: \"+path+\"\\n\", getTag(\"header\"))\n\t\tnewContent := p.Files[path]\n\t\t\n\t\t// Try to find the file locally to show a real diff\n\t\told, _ := os.ReadFile(path)\n\t\toldStr := string(old)\n\n\t\tif oldStr == newContent || oldStr == \"\" {\n\t\t\tstatsBuf.Insert(statsBuf.GetEndIter(), newContent+\"\\n\\n\")\n\t\t} else {\n\t\t\tdiffs := dmp.DiffMain(oldStr, newContent, false)\n\t\t\tfor _, d := range diffs {\n\t\t\t\tswitch d.Type {\n\t\t\t\tcase diffmatchpatch.DiffInsert: statsBuf.InsertWithTag(statsBuf.GetEndIter(), d.Text, getTag(\"added\"))\n\t\t\t\tcase diffmatchpatch.DiffDelete: statsBuf.InsertWithTag(statsBuf.GetEndIter(), d.Text, getTag(\"deleted\"))\n\t\t\t\tdefault: statsBuf.Insert(statsBuf.GetEndIter(), d.Text)\n\t\t\t\t}\n\t\t\t}\n\t\t\tstatsBuf.Insert(statsBuf.GetEndIter(), \"\\n\\n\")\n\t\t}\n\t}\n}\n\nfunc processClipboard(text string) {\n\tre := regexp.MustCompile(`(?s)\\{.*\\\"files\\\".*\\}`)\n\tmatch := re.FindString(text)\n\tif match != \"\" {\n\t\tvar patch model.ProjectOutput\n\t\tif err := json.Unmarshal([]byte(match), \u0026patch); err == nil {\n\t\t\tpendingPatches = append(pendingPatches, patch)\n\t\t\trow, _ := gtk.ListBoxRowNew()\n\t\t\tlbl, _ := gtk.LabelNew(fmt.Sprintf(\"Patch %d (%d files)\", len(pendingPatches), len(patch.Files)))\n\t\t\trow.Add(lbl)\n\t\t\tpendingList.Add(row)\n\t\t\tpendingList.ShowAll()\n\t\t}\n\t}\n}\n\nfunc setupTags(buffer *gtk.TextBuffer) {\n\ttab, _ := buffer.GetTagTable()\n\ttagA, _ := gtk.TextTagNew(\"added\")\n\ttagA.SetProperty(\"background\", \"#1e3a1e\")\n\ttab.Add(tagA)\n\ttagD, _ := gtk.TextTagNew(\"deleted\")\n\ttagD.SetProperty(\"background\", \"#4b1818\")\n\ttab.Add(tagD)\n\ttagH, _ := gtk.TextTagNew(\"header\")\n\ttagH.SetProperty(\"foreground\", \"#569cd6\")\n\ttagH.SetProperty(\"weight\", 700)\n\ttab.Add(tagH)\n}\n\nfunc getTag(n string) *gtk.TextTag {\n\ttab, _ := statsBuf.GetTagTable()\n\ttag, _ := tab.Lookup(n)\n\treturn tag\n}\n\nfunc updateStatus(m string) { glib.IdleAdd(func() { statusLabel.SetText(\"[\" + time.Now().Format(\"15:04:05\") + \"] \" + m) }) }\nfunc refreshStashes(list *gtk.ListBox) { /* simplified for brevity */ }\nfunc mustMarshal(v interface{}) []byte { b, _ := json.MarshalIndent(v, \"\", \"  \"); return b }\nfunc newBtn(l string) *gtk.Button      { b, _ := gtk.ButtonNewWithLabel(l); return b }\nfunc label(box *gtk.Box, t string)     { l, _ := gtk.LabelNew(t); l.SetXAlign(0); box.PackStart(l, false, false, 0) }\n"
  }
}